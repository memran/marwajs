import { promises as fsp } from 'fs';
import { join, relative, sep, posix, dirname, resolve } from 'path';

export type HistoryMode = 'browser' | 'hash';
export type RouteSpec = { path: string; pageSpec: string; layoutSpecs: string[] };

const MARK_START = '/* @marwa:routes:start */';
const MARK_END   = '/* @marwa:routes:end */';

export async function scanAndInject(opts: { appRoot: string; entryFile: string; pagesDir?: string; history?: HistoryMode }) {
  const pagesDir = opts.pagesDir ?? 'pages';
  const history  = opts.history ?? 'browser';
  const routes   = await scanPages({ appRoot: opts.appRoot, pagesDir });
  await injectIntoEntry({ entryFile: opts.entryFile, history, routes });
  return { count: routes.length };
}

export async function scanPages({ appRoot, pagesDir = 'pages' }: { appRoot: string; pagesDir?: string; }): Promise<RouteSpec[]> {
  const base = resolve(appRoot);
  const files = await listMarwaFiles(join(base, pagesDir), base);
  const set = new Set(files);

  const routes: RouteSpec[] = files
    .filter(f => !f.endsWith('/_layout.marwa'))
    .map(f => ({
      path: toRoutePath(f, pagesDir),
      pageSpec: toRelImport(join(base, 'main.ts'), join(base, f)),
      layoutSpecs: chainLayoutsFor(f, pagesDir, set).map(l => toRelImport(join(base, 'main.ts'), join(base, l)))
    }));

  const nf = pickNotFound(set, pagesDir);
  if (nf) {
    routes.push({
      path: '*',
      pageSpec: toRelImport(join(base, 'main.ts'), join(base, nf)),
      layoutSpecs: chainLayoutsFor(nf, pagesDir, set).map(l => toRelImport(join(base, 'main.ts'), join(base, l)))
    });
  }
  return routes;
}

export async function injectIntoEntry({ entryFile, history, routes }: { entryFile: string; history: HistoryMode; routes: RouteSpec[]; }) {
  const block = makeInjectBlock(history, routes);
  const raw = await fsp.readFile(entryFile, 'utf8').catch(() => '');
  if (!raw) throw new Error(`Marwa: entry not found ${entryFile}`);

  const hasStart = raw.includes(MARK_START);
  const hasEnd   = raw.includes(MARK_END);

  if (hasStart && hasEnd) {
    const next = raw.replace(new RegExp(`${escapeRe(MARK_START)}[\\s\\S]*?${escapeRe(MARK_END)}`), block);
    await fsp.writeFile(entryFile, next, 'utf8');
    return;
  }

  const lastImport = Array.from(raw.matchAll(/^\s*import[\s\S]*?;$/gm)).pop();
  const idx = lastImport ? (lastImport.index! + lastImport[0].length) : 0;
  const next = raw.slice(0, idx) + '\n\n' + block + '\n\n' + raw.slice(idx);
  await fsp.writeFile(entryFile, next, 'utf8');
}

/* ----------------------------- internals ------------------------------ */

async function listMarwaFiles(dirAbs: string, baseAbs: string): Promise<string[]> {
  const out: string[] = [];
  async function walk(dir: string) {
    let entries: any[] = [];
    try { entries = await fsp.readdir(dir, { withFileTypes: true }); } catch { return; }
    for (const e of entries) {
      const abs = join(dir, e.name);
      if (e.isDirectory()) await walk(abs);
      else if (e.isFile() && e.name.endsWith('.marwa')) {
        out.push(relative(baseAbs, abs).split(sep).join(posix.sep));
      }
    }
  }
  await walk(dirAbs);
  out.sort();
  return out;
}

function chainLayoutsFor(fileRel: string, pagesDir: string, all: Set<string>): string[] {
  const parts = fileRel.split('/'); parts.pop();
  const res: string[] = [];
  for (let i = 0; i <= parts.length; i++) {
    const dir = [pagesDir, ...parts.slice(0, i)].filter(Boolean).join('/');
    const cand = `${dir}/_layout.marwa`;
    if (all.has(cand)) res.push(cand);
  }
  return res;
}

function toRoutePath(fileRel: string, pagesDir: string): string {
  let p = '/' + fileRel.replace(new RegExp(`^${escapeRe(pagesDir)}/?`), '').replace(/\.marwa$/, '');
  if (/\/index$/i.test(p) || /^\/home$/i.test(p)) p = '/';
  return p;
}

function pickNotFound(all: Set<string>, pagesDir: string): string | null {
  for (const c of [`${pagesDir}/404.marwa`, `${pagesDir}/not-found.marwa`]) if (all.has(c)) return c;
  return null;
}

function toRelImport(fromAbsFile: string, toAbsFile: string): string {
  const rel = relative(dirname(fromAbsFile), toAbsFile).split(sep).join(posix.sep);
  return rel.startsWith('.') ? rel : './' + rel;
}

function makeInjectBlock(history: HistoryMode, routes: RouteSpec[]) {
  const items = routes
    .map(r => `{ path: ${JSON.stringify(r.path)}, loader: () => import('${r.pageSpec}'), layouts: [${r.layoutSpecs.map(s => `() => import('${s}')`).join(', ')}] }`)
    .join(',\n  ');
  return `/* @marwa:routes:start */
//
// AUTO-GENERATED by @marwajs/compiler â€” DO NOT EDIT
//
const __MARWA_HISTORY = ${JSON.stringify(history)};
const __MARWA_ROUTES = [
  ${items}
];
// End
/* @marwa:routes:end */`;
}

function escapeRe(s: string) { return s.replace(/[.*+?^${}()|[\\]{}]/g, '\\$&'); }
