import { join, relative, sep, posix, dirname } from 'path';
import { promises as fsp, existsSync } from 'fs';

const B_START = '/* @marwa:routes:start */';
const B_END   = '/* @marwa:routes:end */';

export async function injectRoutes(opts: {
  appRoot: string;           // e.g. <app>/src
  entryFile: string;         // e.g. <app>/src/main.ts
  pagesDir?: string;         // default 'pages'
  history?: 'browser'|'hash' // default 'browser'
}) {
  const pagesDir = opts.pagesDir ?? 'pages';
  const history = opts.history ?? 'browser';

  const pagesAbs = join(opts.appRoot, pagesDir);

  // 1) Scan pages/*.marwa if folder exists
  const files = existsSync(pagesAbs) ? await listMarwaFiles(pagesAbs, opts.appRoot) : [];
  const allSet = new Set(files);

  // 2) Build routes (skip _layout.marwa)
  const routes = files
    .filter(f => !f.endsWith('/_layout.marwa'))
    .map(f => {
      const path = fileToPath(f, pagesDir);
      const pageSpec = toRelImport(opts.entryFile, join(opts.appRoot, f));
      const layoutSpecs = chainLayoutsFor(f, pagesDir, allSet).map(l => toRelImport(opts.entryFile, join(opts.appRoot, l)));
      return { path, pageSpec, layoutSpecs };
    });

  // 3) Auto NotFound if 404.marwa (or not-found.marwa) exists → push LAST
  const nfRel = pickNotFound(allSet, pagesDir);
  if (nfRel) {
    const pageSpec = toRelImport(opts.entryFile, join(opts.appRoot, nfRel));
    const layoutSpecs = chainLayoutsFor(nfRel, pagesDir, allSet).map(l => toRelImport(opts.entryFile, join(opts.appRoot, l)));
    routes.push({ path: '*', pageSpec, layoutSpecs });
  }

  // 4) Inject into entry between markers (or insert after last import)
  const block = makeBlock(routes, history);
  await writeBetweenMarkers(opts.entryFile, B_START, B_END, block);

  return { count: routes.length };
}

/* ------------------------ helpers -------------------------------------- */

async function listMarwaFiles(dirAbs: string, baseAbs: string): Promise<string[]> {
  const out: string[] = [];
  const ents = await fsp.readdir(dirAbs, { withFileTypes: true });
  for (const ent of ents) {
    const abs = join(dirAbs, ent.name);
    if (ent.isDirectory()) out.push(...await listMarwaFiles(abs, baseAbs));
    else if (ent.isFile() && ent.name.endsWith('.marwa')) out.push(relative(baseAbs, abs).split(sep).join(posix.sep));
  }
  out.sort();
  return out;
}

function chainLayoutsFor(fileRel: string, pagesDir: string, all: Set<string>): string[] {
  const parts = fileRel.split('/'); parts.pop();
  const res: string[] = [];
  for (let i = 0; i <= parts.length; i++) {
    const dir = [pagesDir, ...parts.slice(0, i)].filter(Boolean).join('/');
    const cand = `${dir}/_layout.marwa`;
    if (all.has(cand)) res.push(cand);
  }
  return res;
}

function fileToPath(fileRel: string, pagesDir: string): string {
  let p = '/' + fileRel.replace(new RegExp(`^${pagesDir}/?`), '').replace(/\.marwa$/, '');
  if (/\/index$/i.test(p) || /^\/home$/i.test(p)) p = '/';
  return p.toLowerCase();
}

function pickNotFound(all: Set<string>, pagesDir: string): string | null {
  const cands = [`${pagesDir}/404.marwa`, `${pagesDir}/not-found.marwa`];
  for (const c of cands) if (all.has(c)) return c;
  return null;
}

function toRelImport(fromAbsFile: string, toAbsFile: string): string {
  const fromDir = dirname(fromAbsFile);
  const rel = relative(fromDir, toAbsFile).split(sep).join(posix.sep);
  return rel.startsWith('.') ? rel : './' + rel;
}

function makeBlock(
  routes: Array<{ path: string; pageSpec: string; layoutSpecs: string[] }>,
  history: 'browser'|'hash'
) {
  const items = routes.map(r =>
    `{ path: ${JSON.stringify(r.path)}, loader: () => import('${r.pageSpec}'), layouts: [${r.layoutSpecs.map(s => `() => import('${s}')`).join(', ')}] }`
  ).join(',\n  ');

  return `/* @marwa:routes:start */
//
// AUTO-GENERATED by @marwajs/compiler — DO NOT EDIT
//
const __MARWA_HISTORY = ${JSON.stringify(history)};
const __MARWA_ROUTES = [
  ${items}
];
// End
/* @marwa:routes:end */`;
}

async function writeBetweenMarkers(fileAbs: string, start: string, end: string, block: string) {
  const raw = await fsp.readFile(fileAbs, 'utf8').catch(() => '');
  if (!raw) throw new Error(`Entry file not found: ${fileAbs}`);

  const hasStart = raw.includes(start);
  const hasEnd = raw.includes(end);

  if (hasStart && hasEnd) {
    const updated = raw.replace(new RegExp(`${escapeReg(start)}[\\s\\S]*?${escapeReg(end)}`), block);
    await fsp.writeFile(fileAbs, updated, 'utf8');
    return;
  }

  // Insert after last import (or at top)
  const importMatch = Array.from(raw.matchAll(/^\s*import[\s\S]*?;$/gm)).pop();
  const idx = importMatch ? (importMatch.index! + importMatch[0].length) : 0;
  const updated = raw.slice(0, idx) + '\n\n' + block + '\n\n' + raw.slice(idx);
  await fsp.writeFile(fileAbs, updated, 'utf8');
}

function escapeReg(s: string) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
